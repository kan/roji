package proxy

import (
	"embed"
	"encoding/json"
	"fmt"
	"html/template"
	"log/slog"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strings"
	"time"
)

// sharedTransport is used for connection pooling across all proxied requests
var sharedTransport = &http.Transport{
	MaxIdleConns:        100,
	MaxIdleConnsPerHost: 10,
	IdleConnTimeout:     90 * time.Second,
}

//go:embed templates/*.html
var templateFS embed.FS

var templates = template.Must(template.ParseFS(templateFS, "templates/*.html"))

// StatusConfig contains configuration for the status endpoint
type StatusConfig struct {
	Version       string
	StartTime     time.Time
	CertsDir      string
	AutoGenerated bool
	Network       string
	BaseDomain    string
	HTTPPort      int
	HTTPSPort     int
}

// Handler is the main HTTP handler for the reverse proxy
type Handler struct {
	router        *Router
	dashboardHost string // hostname for dashboard (e.g., "roji.localhost")
	statusConfig  *StatusConfig
}

// NewHandler creates a new proxy handler
func NewHandler(router *Router, dashboardHost string, statusConfig *StatusConfig) *Handler {
	return &Handler{
		router:        router,
		dashboardHost: strings.ToLower(dashboardHost),
		statusConfig:  statusConfig,
	}
}

// ServeHTTP implements http.Handler
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	startTime := time.Now()

	// Extract hostname (remove port if present)
	hostname := r.Host
	if idx := strings.LastIndex(hostname, ":"); idx != -1 {
		hostname = hostname[:idx]
	}
	hostname = strings.ToLower(hostname)

	// Check if this is the dashboard
	if h.dashboardHost != "" && hostname == h.dashboardHost {
		// Health check endpoints
		if r.URL.Path == "/_api/health" || r.URL.Path == "/healthz" {
			h.serveHealth(w, r)
			return
		}
		// Status endpoint
		if r.URL.Path == "/_api/status" {
			h.serveStatus(w, r)
			return
		}
		// API endpoint for route listing
		if r.URL.Path == "/_api/routes" {
			h.serveRoutesAPI(w, r)
			return
		}
		h.serveDashboard(w, r)
		return
	}

	// Look up route
	route := h.router.Lookup(hostname, r.URL.Path)
	if route == nil {
		h.handleNotFound(w, r, hostname)
		return
	}

	// Create reverse proxy for this request
	targetURL := &url.URL{
		Scheme: "http",
		Host:   fmt.Sprintf("%s:%d", route.Backend.Host, route.Backend.Port),
	}

	proxy := httputil.NewSingleHostReverseProxy(targetURL)

	// Use shared transport for connection pooling
	proxy.Transport = sharedTransport

	// SSE support: flush responses immediately (disable buffering)
	proxy.FlushInterval = -1

	// Customize the director to handle path prefixes
	originalDirector := proxy.Director
	proxy.Director = func(req *http.Request) {
		originalDirector(req)

		// Strip path prefix if configured
		if route.PathPrefix != "" {
			req.URL.Path = strings.TrimPrefix(req.URL.Path, route.PathPrefix)
			if req.URL.Path == "" {
				req.URL.Path = "/"
			}
		}

		// Security: Remove existing X-Forwarded-* headers to prevent spoofing
		// Clients could send malicious headers that backends might trust
		req.Header.Del("X-Forwarded-For")
		req.Header.Del("X-Forwarded-Host")
		req.Header.Del("X-Forwarded-Proto")
		req.Header.Del("X-Real-IP")

		// Set X-Forwarded-* headers with trusted values
		req.Header.Set("X-Forwarded-Host", r.Host)
		req.Header.Set("X-Forwarded-Proto", "https")
		if r.RemoteAddr != "" {
			if idx := strings.LastIndex(r.RemoteAddr, ":"); idx != -1 {
				req.Header.Set("X-Forwarded-For", r.RemoteAddr[:idx])
			}
		}
		req.Header.Set("X-Real-IP", req.Header.Get("X-Forwarded-For"))
	}

	// Error handler
	proxy.ErrorHandler = func(w http.ResponseWriter, r *http.Request, err error) {
		slog.Error("proxy error",
			"hostname", hostname,
			"path", r.URL.Path,
			"target", targetURL.String(),
			"error", err)
		http.Error(w, "Bad Gateway", http.StatusBadGateway)
	}

	// Log the request
	proxy.ModifyResponse = func(resp *http.Response) error {
		duration := time.Since(startTime)
		slog.Info("request",
			"method", r.Method,
			"host", hostname,
			"path", r.URL.Path,
			"status", resp.StatusCode,
			"duration", duration.Round(time.Millisecond),
			"target", route.Backend.ServiceName)
		return nil
	}

	proxy.ServeHTTP(w, r)
}

func (h *Handler) serveDashboard(w http.ResponseWriter, r *http.Request) {
	routes := h.router.ListRoutes()

	data := struct {
		Routes []RouteInfo
	}{
		Routes: routes,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	if err := templates.ExecuteTemplate(w, "dashboard.html", data); err != nil {
		slog.Error("failed to render dashboard template", "error", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}

func (h *Handler) serveRoutesAPI(w http.ResponseWriter, r *http.Request) {
	routes := h.router.ListRoutes()

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(routes); err != nil {
		slog.Error("failed to encode routes as JSON", "error", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}

func (h *Handler) serveHealth(w http.ResponseWriter, r *http.Request) {
	routes := h.router.ListRoutes()

	health := struct {
		Status string `json:"status"`
		Routes int    `json:"routes"`
	}{
		Status: "healthy",
		Routes: len(routes),
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(health); err != nil {
		slog.Error("failed to encode health response", "error", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
}

func (h *Handler) serveStatus(w http.ResponseWriter, r *http.Request) {
	routes := h.router.ListRoutes()

	// Build status response
	status := &StatusResponse{
		Version:       h.statusConfig.Version,
		UptimeSeconds: int64(time.Since(h.statusConfig.StartTime).Seconds()),
		Certificates:  getCertificateStatus(h.statusConfig.CertsDir, h.statusConfig.AutoGenerated),
		Docker: DockerStatus{
			Connected: true, // If we're running, Docker is connected
			Network:   h.statusConfig.Network,
		},
		Proxy: ProxyStatus{
			RoutesCount:   len(routes),
			DashboardHost: h.dashboardHost,
			BaseDomain:    h.statusConfig.BaseDomain,
			HTTPPort:      h.statusConfig.HTTPPort,
			HTTPSPort:     h.statusConfig.HTTPSPort,
		},
	}

	// Determine overall health
	status.Health = determineHealth(status)

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(status); err != nil {
		slog.Error("failed to encode status response", "error", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}
}

func (h *Handler) handleNotFound(w http.ResponseWriter, r *http.Request, hostname string) {
	slog.Warn("no route found",
		"hostname", hostname,
		"path", r.URL.Path)

	routes := h.router.ListRoutes()

	data := struct {
		Hostname      string
		Routes        []RouteInfo
		DashboardHost string
	}{
		Hostname:      hostname,
		Routes:        routes,
		DashboardHost: h.dashboardHost,
	}

	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.WriteHeader(http.StatusNotFound)
	if err := templates.ExecuteTemplate(w, "notfound.html", data); err != nil {
		slog.Error("failed to render notfound template", "error", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}

// RedirectHandler redirects HTTP to HTTPS
type RedirectHandler struct {
	HTTPSPort int
}

// ServeHTTP implements http.Handler for HTTP->HTTPS redirect
func (h *RedirectHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	host := r.Host
	if idx := strings.LastIndex(host, ":"); idx != -1 {
		host = host[:idx]
	}

	targetURL := fmt.Sprintf("https://%s", host)
	if h.HTTPSPort != 443 {
		targetURL = fmt.Sprintf("https://%s:%d", host, h.HTTPSPort)
	}
	targetURL += r.URL.RequestURI()

	http.Redirect(w, r, targetURL, http.StatusMovedPermanently)
}
