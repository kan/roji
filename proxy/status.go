package proxy

import (
	"crypto/x509"
	"encoding/pem"
	"os"
	"time"
)

// StatusResponse represents the overall status of roji
type StatusResponse struct {
	Version       string            `json:"version"`
	UptimeSeconds int64             `json:"uptime_seconds"`
	Certificates  CertificateStatus `json:"certificates"`
	Docker        DockerStatus      `json:"docker"`
	Proxy         ProxyStatus       `json:"proxy"`
	Health        string            `json:"health"`
}

// CertificateStatus contains information about TLS certificates
type CertificateStatus struct {
	AutoGenerated bool      `json:"auto_generated"`
	Directory     string    `json:"directory"`
	CA            *CertInfo `json:"ca"`
	Server        *CertInfo `json:"server"`
}

// CertInfo contains details about a specific certificate
type CertInfo struct {
	Exists        bool       `json:"exists"`
	ValidUntil    *time.Time `json:"valid_until,omitempty"`
	DaysRemaining *int       `json:"days_remaining,omitempty"`
	Subject       string     `json:"subject,omitempty"`
	DNSNames      []string   `json:"dns_names,omitempty"` // server cert only
}

// DockerStatus contains Docker connection information
type DockerStatus struct {
	Connected  bool   `json:"connected"`
	Network    string `json:"network"`
	APIVersion string `json:"api_version,omitempty"`
}

// ProxyStatus contains proxy configuration and state
type ProxyStatus struct {
	RoutesCount   int    `json:"routes_count"`
	DashboardHost string `json:"dashboard_host"`
	BaseDomain    string `json:"base_domain"`
	HTTPPort      int    `json:"http_port"`
	HTTPSPort     int    `json:"https_port"`
}

// parseCertificate reads and parses a certificate file
func parseCertificate(path string) *CertInfo {
	info := &CertInfo{Exists: false}

	// Read certificate file
	data, err := os.ReadFile(path)
	if err != nil {
		return info
	}

	// Decode PEM
	block, _ := pem.Decode(data)
	if block == nil {
		return info
	}

	// Parse certificate
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		return info
	}

	info.Exists = true
	info.ValidUntil = &cert.NotAfter
	info.Subject = cert.Subject.String()

	// Calculate days remaining
	daysRemaining := int(time.Until(cert.NotAfter).Hours() / 24)
	info.DaysRemaining = &daysRemaining

	// Add DNS names for server certificates
	if len(cert.DNSNames) > 0 {
		info.DNSNames = cert.DNSNames
	}

	return info
}

// getCertificateStatus reads certificate information from the filesystem
func getCertificateStatus(certsDir string, autoGenerated bool) CertificateStatus {
	status := CertificateStatus{
		AutoGenerated: autoGenerated,
		Directory:     certsDir,
	}

	// Parse CA certificate
	caCertPath := certsDir + "/ca.pem"
	status.CA = parseCertificate(caCertPath)

	// Parse server certificate
	serverCertPath := certsDir + "/cert.pem"
	status.Server = parseCertificate(serverCertPath)

	return status
}

// determineHealth calculates overall health status
func determineHealth(status *StatusResponse) string {
	// Docker not connected -> unhealthy
	if !status.Docker.Connected {
		return "unhealthy"
	}

	// CA certificate expiring within 30 days -> degraded
	if status.Certificates.CA != nil &&
	   status.Certificates.CA.DaysRemaining != nil &&
	   *status.Certificates.CA.DaysRemaining < 30 {
		return "degraded"
	}

	// Server certificate expiring within 30 days -> degraded
	if status.Certificates.Server != nil &&
	   status.Certificates.Server.DaysRemaining != nil &&
	   *status.Certificates.Server.DaysRemaining < 30 {
		return "degraded"
	}

	// CA or Server certificate doesn't exist -> degraded
	if status.Certificates.CA != nil && !status.Certificates.CA.Exists {
		return "degraded"
	}
	if status.Certificates.Server != nil && !status.Certificates.Server.Exists {
		return "degraded"
	}

	return "healthy"
}
